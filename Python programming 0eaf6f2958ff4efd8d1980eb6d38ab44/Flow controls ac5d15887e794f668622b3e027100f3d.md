# Flow controls.

[1. if usage.](https://www.w3schools.com/python/python_conditions.asp)

1. if usage.

<aside>
ðŸ’¡

how to avoid nested if (good programming technique).

Avoiding deeply nested `if` statements is a good programming practice because it improves code readability, maintainability, and reduces complexity. Here are several techniques to avoid or minimize nested `if` statements:

### 1. **Use `return` Early (Guard Clauses)**

Instead of having a large block of code nested inside an `if` condition, you can return early or handle edge cases upfront. This helps reduce the depth of the nesting.

**Before (Nested `if`):**

```python
def process_data(data):
    if data:
        if isinstance(data, dict):
            if 'key' in data:
                # Perform operations here
                print("Processing data...")

```

**After (Using Guard Clauses):**

```python
def process_data(data):
    if not data:
        return
    if not isinstance(data, dict):
        return
    if 'key' not in data:
        return
    # Perform operations here
    print("Processing data...")

```

### 2. **Use `elif` Instead of Nested `if`**

When conditions are mutually exclusive, use `elif` instead of nesting `if` statements.

**Before (Nested `if`):**

```python
if condition1:
    # do something
else:
    if condition2:
        # do something else

```

**After (Using `elif`):**

```python
if condition1:
    # do something
elif condition2:
    # do something else

```

### 3. **Use Logical Operators (`and`, `or`)**

Combine conditions using logical operators when possible, rather than having multiple `if` blocks.

**Before (Nested `if`):**

```python
if condition1:
    if condition2:
        # do something

```

**After (Using `and`):**

```python
if condition1 and condition2:
    # do something

```

### 4. **Use `try-except` for Error Handling**

If you're checking for exceptions, using `try-except` blocks can simplify code by eliminating condition checks.

**Before (Nested `if`):**

```python
if data is not None:
    if 'key' in data:
        # do something

```

**After (Using `try-except`):**

```python
try:
    value = data['key']
    # do something with value
except (TypeError, KeyError):
    pass  # Handle exception or return

```

### 5. **Leverage Dictionaries for Conditional Logic**

For situations where you're handling different cases based on the value of a variable, a dictionary (or mapping) can often replace a long `if-elif` structure.

**Before (Nested `if` or `if-elif`):**

```python
def get_message(status):
    if status == 'success':
        return "Operation was successful"
    elif status == 'error':
        return "There was an error"
    elif status == 'pending':
        return "Operation is still pending"

```

**After (Using a Dictionary):**

```python
def get_message(status):
    messages = {
        'success': "Operation was successful",
        'error': "There was an error",
        'pending': "Operation is still pending"
    }
    return messages.get(status, "Unknown status")

```

### 6. **Use Classes/Polymorphism**

For more complex conditions and operations, object-oriented programming and polymorphism can help distribute logic across multiple classes, avoiding deeply nested `if` statements.

**Before (Complex Conditions):**

```python
if shape == 'circle':
    # Do something for circle
elif shape == 'square':
    # Do something for square

```

**After (Using Classes/Polymorphism):**

```python
class Shape:
    def draw(self):
        pass

class Circle(Shape):
    def draw(self):
        print("Drawing a circle")

class Square(Shape):
    def draw(self):
        print("Drawing a square")

shape = Circle()
shape.draw()  # Handles shape-specific logic

```

### 7. **Refactor into Functions**

If you notice repeated blocks of logic inside nested `if` statements, you can refactor them into separate functions or methods to keep the code more modular and readable.

**Before (Nested Logic):**

```python
def process(data):
    if validate_data(data):
        if check_conditions(data):
            # Do something

```

**After (Refactoring into Functions):**

```python
def process(data):
    if not validate_data(data):
        return
    if not check_conditions(data):
        return
    # Do something

```

### 8. **Use Ternary Operator for Simple Conditions**

For simple `if-else` conditions, Pythonâ€™s ternary operator can reduce multiple lines to a single expression.

**Before (Simple `if-else`):**

```python
if x > 10:
    result = 'large'
else:
    result = 'small'

```

**After (Ternary Operator):**

```python
result = 'large' if x > 10 else 'small'

```

### Conclusion

By applying these techniques, you can make your code cleaner and easier to maintain. Choosing the right approach depends on the specific context and complexity of the code, but the general goal is always to reduce complexity and improve readability.

</aside>

## Omitting the "else" clause (using an "if" without an "else")

Omitting the "else" clause, or using an "if" statement without an "else", is a common practice in programming that can lead to cleaner and more readable code. Here's how and when to do it:

### When to Omit the "else" Clause

1. When the default behavior is to do nothing or continue with the next part of the code.
2. When you're using early returns or guard clauses.
3. When you're setting a variable based on a condition, but it already has a default value.

### Examples

**1. Performing a specific action only when a condition is met:**

```python
if user.is_admin:
    perform_admin_action()
# No else needed, regular users simply continue with the next part of the code
```

**2. Using early returns (guard clauses):**

```python
def process_data(data):
    if not data:
        return  # Early return if data is empty
    
    # Process the data here
    print("Processing data...")
```

**3. Setting a variable with a default value:**

```python
discount = 0  # Default value
if customer.is_premium:
    discount = 0.1
# No else needed, non-premium customers keep the default 0 discount
```

By omitting unnecessary "else" clauses, you can reduce nesting and make your code more straightforward and easier to read. This approach aligns with the principle of writing clean, concise code that's easy to understand and maintain.

[2.while loop](https://www.w3schools.com/python/python_while_loops.asp)

2.while loop

python does not have â€œdo- - untilâ€

Python doesn't have a "do-until" loop primarily due to design choices and language philosophy. Here are some reasons why:

1. **Simplicity and consistency:** Python aims to be a simple and consistent language. Having both "while" and "do-until" loops could be seen as redundant, as a "do-until" loop can be easily replicated using a "while" loop.
2. **Pythonic approach:** Python's design philosophy emphasizes clarity and readability. The creators likely felt that a single loop construct (while) was sufficient and more in line with the "There should be one-- and preferably only one --obvious way to do it" principle from the Zen of Python.
3. **Flexibility of while loops:** Python's "while" loop can easily mimic the behavior of a "do-until" loop by using a condition that's always true and a break statement:

```python
while True:
    # Do something
    if condition:
        break
```

1. **Historical reasons:** Python's design was influenced by languages like C and ABC, which use while loops. The creators may have decided to stick with this familiar construct.

While some developers might miss the "do-until" loop, Python's existing constructs are generally considered sufficient for expressing all necessary loop logic clearly and concisely.

## Using Infinite While and Do-While Loops in Python

### Infinite While Loop

In Python, you can create an infinite while loop using the following structure:

```python
while True:
    # Your code here
    if exit_condition:
        break
```

This loop will continue indefinitely until the exit_condition is met, causing the loop to break.

### Simulating a Do-While Loop

Python doesn't have a built-in do-while loop, but you can simulate one using a while True loop with a break statement:

```python
while True:
    # Your code here (executed at least once)
    if not condition:
        break
```

This structure ensures that the code inside the loop is executed at least once before checking the condition to continue or break the loop.

### Example: Infinite While Loop

```python
count = 0
while True:
    print(f"Count: {count}")
    count += 1
    if count >= 5:
        break
```

This example will print the count from 0 to 4 before breaking the loop.

### Example: Simulated Do-While Loop

```python
user_input = ""
while True:
    user_input = input("Enter 'quit' to exit: ")
    print(f"You entered: {user_input}")
    if user_input.lower() == 'quit':
        break
```

This simulated do-while loop will always ask for input at least once, then continue asking until the user enters 'quit'.

Remember to always include a way to exit infinite loops to prevent your program from hanging indefinitely.

[3.for loop](https://www.w3schools.com/python/python_for_loops.asp)

3.for loop

In Python, there are several concise ways to create infinite loops. Here are some common methods:

### 1. Using while True

```python
while True:
    # Your code here
```

This is the most straightforward and commonly used method.

### 2. Using for loop with itertools.count()

```python
import itertools

for _ in itertools.count():
    # Your code here
```

This method uses the itertools.count() function, which generates an infinite sequence of numbers.

### 3. Using for loop with iter() and a function

```python
for _ in iter(int, 1):
    # Your code here
```

This creates an iterator that calls int() repeatedly until it returns 1 (which it never will).

Remember, when using infinite loops, it's crucial to include a way to break out of the loop (using break or return) to avoid hanging your program indefinitely.